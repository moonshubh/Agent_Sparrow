'use client';

import React, { memo, useEffect, useRef, useState, useCallback } from 'react';
import { X, Copy, Check, Download, Maximize2, Minimize2, Code, Eye, GripVertical, ChevronLeft, ChevronRight, Trash2 } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import mermaid from 'mermaid';
import { cn } from '@/shared/lib/utils';
import { useCurrentArtifact, useArtifactsVisible, useArtifactStore, useArtifactSelector } from './ArtifactContext';
import { MermaidEditor } from './MermaidEditor';
import { ArticleEditor } from './ArticleEditor';
import type { Artifact, ArtifactType } from './types';

interface ResizeHandleProps {
  direction: string;
  className: string;
  isActive: boolean;
  onResizeStart: (event: React.MouseEvent, direction: string) => void;
}

function ResizeHandle({ direction, className, isActive, onResizeStart }: ResizeHandleProps) {
  const cursor = direction.includes('n') && direction.includes('e') ? 'nesw-resize'
    : direction.includes('n') && direction.includes('w') ? 'nwse-resize'
    : direction.includes('s') && direction.includes('e') ? 'nwse-resize'
    : direction.includes('s') && direction.includes('w') ? 'nesw-resize'
    : direction.includes('n') || direction.includes('s') ? 'ns-resize'
    : 'ew-resize';

  return (
    <div
      className={cn(
        'absolute z-10 opacity-0 hover:opacity-100 transition-opacity',
        className,
        isActive && 'opacity-100'
      )}
      onMouseDown={(e) => onResizeStart(e, direction)}
      style={{ cursor }}
    />
  );
}

// Initialize mermaid with dark theme
mermaid.initialize({
  startOnLoad: false,
  theme: 'dark',
  themeVariables: {
    primaryColor: '#c4704f',
    primaryTextColor: '#faf6f0',
    primaryBorderColor: '#c4704f',
    lineColor: '#8b7355',
    secondaryColor: '#2d2a26',
    tertiaryColor: '#1a1816',
    background: '#1a1816',
    mainBkg: '#2d2a26',
    nodeBorder: '#c4704f',
    clusterBkg: '#2d2a26',
    titleColor: '#faf6f0',
    edgeLabelBackground: '#2d2a26',
  },
  flowchart: {
    curve: 'basis',
    padding: 20,
  },
  securityLevel: 'strict',
});

/**
 * Sanitize mermaid content to fix common parsing issues.
 * Models sometimes generate invalid syntax like <br/> tags.
 */
function sanitizeMermaidContent(content: string): string {
  let sanitized = content;

  // Replace <br/> and <br> tags with newlines in node labels
  // These are commonly generated by LLMs but not valid mermaid syntax
  sanitized = sanitized.replace(/<br\s*\/?>/gi, '\\n');

  // Remove HTML entities that might cause issues
  sanitized = sanitized.replace(/&nbsp;/g, ' ');
  sanitized = sanitized.replace(/&amp;/g, '&');
  sanitized = sanitized.replace(/&lt;/g, '<');
  sanitized = sanitized.replace(/&gt;/g, '>');

  // Fix parentheses inside node labels that cause parsing issues
  // Replace (text) with [text] inside square brackets
  // Pattern: [content(inner)more] -> [content - inner - more]
  sanitized = sanitized.replace(/\[([^\]]*)\(([^)]*)\)([^\]]*)\]/g, (match, before, inner, after) => {
    return `[${before}${inner}${after}]`;
  });

  return sanitized;
}

interface MermaidRendererProps {
  content: string;
  id: string;
}

/**
 * MermaidRenderer - Renders mermaid diagram content
 */
const MermaidRenderer = memo(function MermaidRenderer({ content, id }: MermaidRendererProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [svg, setSvg] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    let cancelled = false;

    const renderDiagram = async () => {
      // Handle missing content
      if (!content) {
        setError('No diagram content provided');
        setIsLoading(false);
        return;
      }

      setIsLoading(true);
      setError(null);

      try {
        // Generate unique ID for this render
        const rendererId = `mermaid-${id}-${Date.now()}`;

        // Sanitize content to fix common LLM-generated syntax issues
        const sanitizedContent = sanitizeMermaidContent(content);

        // Render the diagram
        const { svg: renderedSvg } = await mermaid.render(rendererId, sanitizedContent);

        if (!cancelled) {
          setSvg(renderedSvg);
          setIsLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          console.error('Mermaid render error:', err);
          setError(err instanceof Error ? err.message : 'Failed to render diagram');
          setIsLoading(false);
        }
      }
    };

    renderDiagram();

    return () => {
      cancelled = true;
    };
  }, [content, id]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64 text-muted-foreground">
        <div className="flex items-center gap-2">
          <div className="animate-spin h-5 w-5 border-2 border-primary border-t-transparent rounded-full" />
          <span>Rendering diagram...</span>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 bg-red-500/10 border border-red-500/20 rounded-lg">
        <p className="text-red-400 font-medium">Diagram Error</p>
        <p className="text-red-300 text-sm mt-1">{error}</p>
        <pre className="mt-2 text-xs text-muted-foreground bg-secondary/50 p-2 rounded overflow-auto">
          {content}
        </pre>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className="mermaid-container flex items-center justify-center p-4 overflow-auto"
      dangerouslySetInnerHTML={{ __html: svg }}
    />
  );
});

/**
 * CodeRenderer - Renders code artifacts with syntax highlighting
 */
const CodeRenderer = memo(function CodeRenderer({ content, language }: { content: string; language?: string }) {
  return (
    <div className="relative overflow-auto rounded-lg">
      <pre className="p-4 bg-[hsl(var(--code-block-bg))] text-sm font-mono">
        <code className={language ? `language-${language}` : ''}>
          {content}
        </code>
      </pre>
    </div>
  );
});

// Default panel dimensions and position
const DEFAULT_WIDTH = 800;
const DEFAULT_HEIGHT = 600;
const MIN_WIDTH = 400;
const MIN_HEIGHT = 300;

// Mobile breakpoint
const MOBILE_BREAKPOINT = 768;

/**
 * Hook to detect mobile viewport
 */
function useIsMobile(): boolean {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };

    // Check on mount
    checkMobile();

    // Listen for resize
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  return isMobile;
}

/**
 * ArtifactPanel - Draggable, resizable overlay panel for viewing artifacts
 *
 * Features:
 * - Draggable by header
 * - Resizable from corners and edges
 * - Close with ESC or click outside
 * - Fullscreen toggle
 * - Preview/Code view toggle for mermaid
 */
export const ArtifactPanel = memo(function ArtifactPanel() {
  const artifact = useCurrentArtifact();
  const isVisible = useArtifactsVisible();
  const { setCurrentArtifact, setArtifactsVisible, removeArtifact } = useArtifactStore();
  const orderedIds = useArtifactSelector((s) => s.orderedIds);
  const artifactsById = useArtifactSelector((s) => s.artifactsById);
  const isMobile = useIsMobile();
  
  const [copied, setCopied] = useState(false);
  const [viewMode, setViewMode] = useState<'preview' | 'code' | 'editor'>('preview');
  const [isFullscreen, setIsFullscreen] = useState(false);

  const getCenteredPosition = () => {
    if (typeof window === 'undefined') {
      return { x: 0, y: 0 };
    }
    const x = (window.innerWidth - DEFAULT_WIDTH) / 2;
    const y = (window.innerHeight - DEFAULT_HEIGHT) / 2;
    return { x: Math.max(0, x), y: Math.max(0, y) };
  };

  // Panel position and size state (desktop)
  const [position, setPosition] = useState(getCenteredPosition);
  const [size, setSize] = useState({ width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT });
  const [isDragging, setIsDragging] = useState(false);
  const [isResizing, setIsResizing] = useState<string | null>(null);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [initialPos, setInitialPos] = useState({ x: 0, y: 0 });
  const [initialSize, setInitialSize] = useState({ width: 0, height: 0 });

  // Mobile bottom sheet state
  const [mobileHeight, setMobileHeight] = useState(85); // % of viewport height
  const [isMobileDragging, setIsMobileDragging] = useState(false);
  const mobileDragStartY = useRef(0);
  const mobileDragStartHeight = useRef(85);

  const panelRef = useRef<HTMLDivElement>(null);

  // Calculate current artifact index for navigation
  const currentIndex = artifact ? orderedIds.indexOf(artifact.id) : -1;
  const hasMultipleArtifacts = orderedIds.length > 1;

  // Navigate to previous/next artifact
  const handlePrevArtifact = useCallback(() => {
    if (currentIndex > 0) {
      setCurrentArtifact(orderedIds[currentIndex - 1]);
    }
  }, [currentIndex, orderedIds, setCurrentArtifact]);

  const handleNextArtifact = useCallback(() => {
    if (currentIndex < orderedIds.length - 1) {
      setCurrentArtifact(orderedIds[currentIndex + 1]);
    }
  }, [currentIndex, orderedIds, setCurrentArtifact]);

  const handleClose = useCallback(() => {
    if (isMobile) {
      // Reset mobile height on close
      setMobileHeight(85);
    }
    setCurrentArtifact(null);
    setArtifactsVisible(false);
  }, [setCurrentArtifact, setArtifactsVisible, isMobile]);

  // Handle delete artifact
  const handleDelete = useCallback(() => {
    if (!artifact) return;

    const currentId = artifact.id;

    // Navigate to adjacent artifact or close panel
    if (orderedIds.length > 1) {
      // If there are other artifacts, navigate to the previous or next one
      const nextIndex = currentIndex < orderedIds.length - 1
        ? currentIndex + 1
        : currentIndex - 1;
      setCurrentArtifact(orderedIds[nextIndex]);
    } else {
      // Last artifact - close the panel
      setCurrentArtifact(null);
      setArtifactsVisible(false);
    }

    // Remove the artifact after navigation
    removeArtifact(currentId);
  }, [artifact, currentIndex, orderedIds, setCurrentArtifact, setArtifactsVisible, removeArtifact]);

  // Mobile drag handlers for bottom sheet
  const handleMobileDragStart = useCallback((e: React.PointerEvent) => {
    setIsMobileDragging(true);
    mobileDragStartY.current = e.clientY;
    mobileDragStartHeight.current = mobileHeight;
    (e.target as HTMLElement).setPointerCapture(e.pointerId);
  }, [mobileHeight]);

  const handleMobileDragMove = useCallback((e: React.PointerEvent) => {
    if (!isMobileDragging) return;

    const deltaY = mobileDragStartY.current - e.clientY;
    const viewportHeight = window.innerHeight;
    const deltaPercentage = (deltaY / viewportHeight) * 100;
    const newHeight = Math.max(20, Math.min(100, mobileDragStartHeight.current + deltaPercentage));

    setMobileHeight(newHeight);
  }, [isMobileDragging]);

  const handleMobileDragEnd = useCallback((e: React.PointerEvent) => {
    if (!isMobileDragging) return;

    setIsMobileDragging(false);
    (e.target as HTMLElement).releasePointerCapture(e.pointerId);

    // Snap to positions based on final height
    if (mobileHeight < 30) {
      handleClose();
    } else if (mobileHeight > 90) {
      setMobileHeight(100);
    } else if (mobileHeight < 55) {
      setMobileHeight(50);
    } else {
      setMobileHeight(85);
    }
  }, [isMobileDragging, mobileHeight, handleClose]);

  const handleCopy = useCallback(async () => {
    if (!artifact) return;

    try {
      await navigator.clipboard.writeText(artifact.content);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  }, [artifact]);

  const handleDownload = useCallback(() => {
    if (!artifact) return;

    // Handle image downloads
    if (artifact.type === 'image' && artifact.imageData) {
      const mimeType = artifact.mimeType || 'image/png';
      const extension = mimeType.split('/')[1] || 'png';

      // Convert base64 to blob
      const byteCharacters = atob(artifact.imageData);
      const byteNumbers = new Array(byteCharacters.length);
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      const byteArray = new Uint8Array(byteNumbers);
      const blob = new Blob([byteArray], { type: mimeType });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${artifact.title.replace(/\s+/g, '_')}.${extension}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      return;
    }

    const extension = artifact.type === 'mermaid' ? 'mmd'
      : artifact.type === 'html' ? 'html'
      : artifact.type === 'react' ? 'tsx'
      : artifact.type === 'kb-article' ? 'md'
      : artifact.language || 'txt';

    const blob = new Blob([artifact.content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${artifact.title.replace(/\s+/g, '_')}.${extension}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [artifact]);

  // Handle drag start
  const handleDragStart = useCallback((e: React.MouseEvent) => {
    if (isFullscreen) return;
    e.preventDefault();
    setIsDragging(true);
    setDragStart({ x: e.clientX, y: e.clientY });
    setInitialPos({ ...position });
  }, [position, isFullscreen]);

  // Handle resize start
  const handleResizeStart = useCallback((e: React.MouseEvent, direction: string) => {
    if (isFullscreen) return;
    e.preventDefault();
    e.stopPropagation();
    setIsResizing(direction);
    setDragStart({ x: e.clientX, y: e.clientY });
    setInitialPos({ ...position });
    setInitialSize({ ...size });
  }, [position, size, isFullscreen]);

  // Handle mouse move for drag and resize
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (isDragging) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        setPosition({
          x: Math.max(0, Math.min(window.innerWidth - size.width, initialPos.x + dx)),
          y: Math.max(0, Math.min(window.innerHeight - size.height, initialPos.y + dy)),
        });
      } else if (isResizing) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;

        let newWidth = initialSize.width;
        let newHeight = initialSize.height;
        let newX = initialPos.x;
        let newY = initialPos.y;

        // Handle resize directions
        if (isResizing.includes('e')) {
          newWidth = Math.max(MIN_WIDTH, initialSize.width + dx);
        }
        if (isResizing.includes('w')) {
          const proposedWidth = initialSize.width - dx;
          if (proposedWidth >= MIN_WIDTH) {
            newWidth = proposedWidth;
            newX = initialPos.x + dx;
          }
        }
        if (isResizing.includes('s')) {
          newHeight = Math.max(MIN_HEIGHT, initialSize.height + dy);
        }
        if (isResizing.includes('n')) {
          const proposedHeight = initialSize.height - dy;
          if (proposedHeight >= MIN_HEIGHT) {
            newHeight = proposedHeight;
            newY = initialPos.y + dy;
          }
        }

        setSize({ width: newWidth, height: newHeight });
        setPosition({ x: newX, y: newY });
      }
    };

    const handleMouseUp = () => {
      setIsDragging(false);
      setIsResizing(null);
    };

    if (isDragging || isResizing) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [isDragging, isResizing, dragStart, initialPos, initialSize, size]);

  // Close on escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isVisible) {
        handleClose();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isVisible, handleClose]);

  // Render content based on artifact type
  const renderContent = () => {
    if (!artifact) return null;

    // Editor mode for mermaid - full split view editor
    if (viewMode === 'editor' && artifact.type === 'mermaid') {
      return <MermaidEditor artifact={artifact} />;
    }

    // In code view mode, always show code
    if (viewMode === 'code') {
      return <CodeRenderer content={artifact.content} language={artifact.language || artifact.type} />;
    }

    // Preview mode
    switch (artifact.type) {
      case 'mermaid':
        return <MermaidRenderer content={artifact.content} id={artifact.id} />;

      case 'html':
        // Sandbox HTML preview
        return (
          <iframe
            srcDoc={artifact.content}
            className="w-full h-full min-h-[400px] bg-white rounded-lg"
            sandbox="allow-scripts"
            title={artifact.title}
          />
        );

      case 'image':
        // Image artifact with full resolution display
        const imageSrc = artifact.imageData
          ? `data:${artifact.mimeType || 'image/png'};base64,${artifact.imageData}`
          : artifact.content; // Fallback to content if imageData not available
        return (
          <div className="flex flex-col items-center justify-center h-full gap-4">
            <img
              src={imageSrc}
              alt={artifact.altText || artifact.title}
              className="max-w-full max-h-[calc(100%-4rem)] object-contain rounded-lg shadow-lg"
            />
            {(artifact.aspectRatio || artifact.resolution) && (
              <div className="flex items-center gap-3 text-sm text-muted-foreground">
                {artifact.aspectRatio && (
                  <span className="px-2 py-0.5 bg-secondary rounded">
                    {artifact.aspectRatio}
                  </span>
                )}
                {artifact.resolution && (
                  <span className="px-2 py-0.5 bg-secondary rounded">
                    {artifact.resolution}
                  </span>
                )}
              </div>
            )}
          </div>
        );

      case 'kb-article':
        // KB article preview - render as styled markdown/HTML
        return (
          <div className="prose prose-invert prose-sm max-w-none p-6 overflow-auto">
            <div dangerouslySetInnerHTML={{ __html: artifact.content }} />
          </div>
        );

      case 'article':
        // Article with images - uses ArticleEditor with built-in edit/preview
        return <ArticleEditor key={artifact.id} artifact={artifact} />;

      case 'react':
      case 'code':
      default:
        return <CodeRenderer content={artifact.content} language={artifact.language || artifact.type} />;
    }
  };

  // Check if current artifact supports editor mode (article has its own built-in editor)
  const supportsEditor = artifact?.type === 'mermaid';

  return (
    <AnimatePresence>
      {isVisible && artifact && (
        <>
          {/* Backdrop - click to close */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
            className={cn(
              "fixed inset-0 z-[100]",
              isMobile 
                ? "bg-black/60 backdrop-blur-sm" 
                : "bg-background/80 backdrop-blur-sm"
            )}
            onClick={handleClose}
          />

          {/* Panel - Mobile or Desktop */}
          <motion.div
            ref={panelRef}
            initial={isMobile ? { y: '100%' } : { opacity: 0, scale: 0.95 }}
            animate={isMobile ? { y: 0 } : { opacity: 1, scale: 1 }}
            exit={isMobile ? { y: '100%' } : { opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.25, ease: [0.4, 0, 0.2, 1] }}
            className={cn(
              'fixed z-[101] bg-card border border-border shadow-2xl overflow-hidden flex flex-col',
              isMobile 
                ? 'inset-x-0 bottom-0 rounded-t-2xl'
                : 'rounded-xl',
              (isDragging || isResizing || isMobileDragging) && 'select-none'
            )}
            style={
              isMobile
                ? { height: `${mobileHeight}vh` }
                : isFullscreen
                  ? { top: 16, left: 16, right: 16, bottom: 16, width: 'auto', height: 'auto' }
                  : { top: position.y, left: position.x, width: size.width, height: size.height }
            }
            onClick={(e) => e.stopPropagation()}
          >
            {/* Mobile drag handle */}
            {isMobile && (
              <div
                className="flex-shrink-0 flex items-center justify-center py-2 cursor-grab active:cursor-grabbing bg-secondary/30"
                onPointerDown={handleMobileDragStart}
                onPointerMove={handleMobileDragMove}
                onPointerUp={handleMobileDragEnd}
                onPointerCancel={handleMobileDragEnd}
              >
                <div className="w-10 h-1 rounded-full bg-muted-foreground/40" />
              </div>
            )}

            {/* Resize handles (only when not fullscreen and not mobile) */}
            {!isFullscreen && !isMobile && (
              <>
                {/* Edge handles */}
                <ResizeHandle
                  direction="n"
                  className="top-0 left-4 right-4 h-2 -mt-1"
                  isActive={isResizing === 'n'}
                  onResizeStart={handleResizeStart}
                />
                <ResizeHandle
                  direction="s"
                  className="bottom-0 left-4 right-4 h-2 -mb-1"
                  isActive={isResizing === 's'}
                  onResizeStart={handleResizeStart}
                />
                <ResizeHandle
                  direction="e"
                  className="right-0 top-4 bottom-4 w-2 -mr-1"
                  isActive={isResizing === 'e'}
                  onResizeStart={handleResizeStart}
                />
                <ResizeHandle
                  direction="w"
                  className="left-0 top-4 bottom-4 w-2 -ml-1"
                  isActive={isResizing === 'w'}
                  onResizeStart={handleResizeStart}
                />
                {/* Corner handles */}
                <ResizeHandle
                  direction="nw"
                  className="top-0 left-0 w-4 h-4 -mt-1 -ml-1"
                  isActive={isResizing === 'nw'}
                  onResizeStart={handleResizeStart}
                />
                <ResizeHandle
                  direction="ne"
                  className="top-0 right-0 w-4 h-4 -mt-1 -mr-1"
                  isActive={isResizing === 'ne'}
                  onResizeStart={handleResizeStart}
                />
                <ResizeHandle
                  direction="sw"
                  className="bottom-0 left-0 w-4 h-4 -mb-1 -ml-1"
                  isActive={isResizing === 'sw'}
                  onResizeStart={handleResizeStart}
                />
                <ResizeHandle
                  direction="se"
                  className="bottom-0 right-0 w-4 h-4 -mb-1 -mr-1"
                  isActive={isResizing === 'se'}
                  onResizeStart={handleResizeStart}
                />
              </>
            )}

            {/* Header - draggable on desktop */}
            <div
              className={cn(
                'flex items-center justify-between px-4 py-3 border-b border-border bg-secondary/30',
                !isFullscreen && !isMobile && 'cursor-move'
              )}
              onMouseDown={!isMobile ? handleDragStart : undefined}
            >
              <div className="flex items-center gap-2 min-w-0">
                {/* Artifact navigation */}
                {hasMultipleArtifacts && (
                  <div className="flex items-center gap-0.5 mr-1">
                    <button
                      onClick={handlePrevArtifact}
                      disabled={currentIndex <= 0}
                      className={cn(
                        'p-1 rounded hover:bg-secondary transition-colors',
                        currentIndex <= 0 
                          ? 'text-muted-foreground/30 cursor-not-allowed' 
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                      title="Previous artifact"
                    >
                      <ChevronLeft className="h-4 w-4" />
                    </button>
                    <span className="text-xs text-muted-foreground tabular-nums">
                      {currentIndex + 1}/{orderedIds.length}
                    </span>
                    <button
                      onClick={handleNextArtifact}
                      disabled={currentIndex >= orderedIds.length - 1}
                      className={cn(
                        'p-1 rounded hover:bg-secondary transition-colors',
                        currentIndex >= orderedIds.length - 1 
                          ? 'text-muted-foreground/30 cursor-not-allowed' 
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                      title="Next artifact"
                    >
                      <ChevronRight className="h-4 w-4" />
                    </button>
                  </div>
                )}
                
                {!isFullscreen && !isMobile && (
                  <GripVertical className="h-4 w-4 text-muted-foreground/50 flex-shrink-0" />
                )}
                <h2 className="font-semibold text-foreground truncate max-w-[200px] sm:max-w-[300px]">
                  {artifact.title}
                </h2>
                <span className="px-2 py-0.5 rounded-full bg-primary/20 text-primary text-xs font-medium flex-shrink-0">
                  {artifact.type}
                </span>
              </div>

              <div className="flex items-center gap-1" onMouseDown={(e) => e.stopPropagation()}>
                {/* View mode toggle (for mermaid with preview + code + editor) */}
                {supportsEditor && (
                  <div className="flex items-center bg-secondary rounded-lg p-0.5 mr-2">
                    <button
                      onClick={() => setViewMode('preview')}
                      className={cn(
                        'px-2 py-1 rounded text-xs font-medium transition-colors',
                        viewMode === 'preview'
                          ? 'bg-primary text-primary-foreground'
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                      title="Preview"
                    >
                      <Eye className="h-3.5 w-3.5" />
                    </button>
                    <button
                      onClick={() => setViewMode('editor')}
                      className={cn(
                        'px-2 py-1 rounded text-xs font-medium transition-colors',
                        viewMode === 'editor'
                          ? 'bg-primary text-primary-foreground'
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                      title="Edit"
                    >
                      <span className="text-[10px] font-semibold">Edit</span>
                    </button>
                    <button
                      onClick={() => setViewMode('code')}
                      className={cn(
                        'px-2 py-1 rounded text-xs font-medium transition-colors',
                        viewMode === 'code'
                          ? 'bg-primary text-primary-foreground'
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                      title="Code"
                    >
                      <Code className="h-3.5 w-3.5" />
                    </button>
                  </div>
                )}
                
                {/* Simple preview/code toggle for non-mermaid */}
                {artifact.type === 'html' && (
                  <div className="flex items-center bg-secondary rounded-lg p-0.5 mr-2">
                    <button
                      onClick={() => setViewMode('preview')}
                      className={cn(
                        'px-2 py-1 rounded text-xs font-medium transition-colors',
                        viewMode === 'preview'
                          ? 'bg-primary text-primary-foreground'
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                    >
                      <Eye className="h-3.5 w-3.5" />
                    </button>
                    <button
                      onClick={() => setViewMode('code')}
                      className={cn(
                        'px-2 py-1 rounded text-xs font-medium transition-colors',
                        viewMode === 'code'
                          ? 'bg-primary text-primary-foreground'
                          : 'text-muted-foreground hover:text-foreground'
                      )}
                    >
                      <Code className="h-3.5 w-3.5" />
                    </button>
                  </div>
                )}

                <button
                  onClick={handleCopy}
                  className="p-2 rounded-lg hover:bg-secondary transition-colors text-muted-foreground hover:text-foreground"
                  title="Copy code"
                >
                  {copied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </button>

                <button
                  onClick={handleDownload}
                  className="p-2 rounded-lg hover:bg-secondary transition-colors text-muted-foreground hover:text-foreground"
                  title="Download"
                >
                  <Download className="h-4 w-4" />
                </button>

                {!isMobile && (
                  <button
                    onClick={() => setIsFullscreen(!isFullscreen)}
                    className="p-2 rounded-lg hover:bg-secondary transition-colors text-muted-foreground hover:text-foreground"
                    title={isFullscreen ? 'Exit fullscreen' : 'Fullscreen'}
                  >
                    {isFullscreen ? <Minimize2 className="h-4 w-4" /> : <Maximize2 className="h-4 w-4" />}
                  </button>
                )}

                <button
                  onClick={handleDelete}
                  className="p-2 rounded-lg hover:bg-red-500/20 transition-colors text-muted-foreground hover:text-red-400"
                  title="Delete artifact"
                >
                  <Trash2 className="h-4 w-4" />
                </button>

                <button
                  onClick={handleClose}
                  className="p-2 rounded-lg hover:bg-secondary transition-colors text-muted-foreground hover:text-foreground ml-1"
                  title="Close (Esc)"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>
            </div>

            {/* Content */}
            <div className={cn(
              "flex-1 overflow-auto bg-background/50",
              viewMode !== 'editor' && "p-4"
            )}>
              {renderContent()}
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
});

export default ArtifactPanel;
